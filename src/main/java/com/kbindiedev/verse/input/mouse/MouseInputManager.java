package com.kbindiedev.verse.input.mouse;

import com.kbindiedev.verse.profiling.Assertions;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

/**
 * A handler for mouse inputs. You can attach an external event listener, or query this class for states.
 *
 * All inputs are related to what you find in {@link MouseButtons}.
 *
 * MouseClick events are always dispatched following a mouseUp event.
 *
 * @see MouseButtons
 * @see IMouseInputProcessor
 */
public class MouseInputManager {

    private HashMap<Integer, Boolean> buttonStates = new HashMap<>();        // maps button number to button state
    private HashMap<Integer, Long> buttonStatesTimestamps = new HashMap<>(); // timestamps (unix) for when state last changed
    private HashSet<Integer> buttonChanges = new HashSet<>();                // map of buttons that changed their state since "iterate"
    private ArrayList<MouseEvent> unhandledEvents = new ArrayList<>();       // events are piled and handled during "iterate"
    private ArrayList<Runnable> dispatchList = new ArrayList<>();            // events to be dispatched, generated during "iterate"
    private int currentMouseX = 0, currentMouseY = 0;

    private long unixThisIteration = System.currentTimeMillis();
    private long unixLastMoveOrDrag = unixThisIteration;

    private boolean isAnyButtonPressed = false;

    /** Initialize processor to blank. */
    private IMouseInputProcessor processor = new IMouseInputProcessor() {
        @Override public boolean mouseDown(int screenX, int screenY, int button) { return false; }
        @Override public boolean mouseUp(int screenX, int screenY, int button) { return false; }
        @Override public boolean mouseClicked(int screenX, int screenY, int button, float holdDuration) { return false; }
        @Override public boolean mouseDragged(int screenX, int screenY) { return false; }
        @Override public boolean mouseMoved(int screenX, int screenY) { return false; }
        @Override public boolean mouseScrolled(float amountX, float amountY) { return false; }
    };

    /** Set the IMouseInputProcessor. */
    public void setProcessor(IMouseInputProcessor p) { processor = p; }

    /**
     * Check if a button is pressed.
     * @param button - The button code {@see MouseButtons}
     * @return true if button by button code is pressed, false otherwise
     */
    public boolean isButtonDown(int button) { return buttonStates.getOrDefault(button, false); }

    /**
     * Get the x coordinate of the last recorded mouse position.
     * @return the x coordinate of the mouse position.
     */
    public int getMouseX() { return currentMouseX; }

    /**
     * Get the y coordinate of the last recorded mouse position.
     * @return the y coordinate of the mouse position.
     */
    public int getMouseY() { return currentMouseY; }

    /**
     * Check if a button was pressed this iteration.
     * @param button - The button code {@see MouseButtons}.
     * @return true if button by button code was pressed this iteration.
     */
    public boolean wasButtonPressedThisIteration(int button) {
        return buttonChanges.contains(button) && buttonStates.get(button);
    }

    /**
     * Check if a button was released this iteration.
     * @param button - The button code {@see MouseButtons}.
     * @return true if button by button code was released this iteration.
     */
    public boolean wasButtonReleasedThisIteration(int button) {
        return buttonChanges.contains(button) && !buttonStates.get(button);
    }

    /**
     * Perform a single iteration.
     * All unhandled (queued) events will be handled and dispatched to self and {@link #processor}.
     * All events are handled "in-order", and are then dispatched "in-order" after handling is complete.
     */
    public void iterate() {
        buttonChanges.clear();

        unixThisIteration = System.currentTimeMillis();

        for (MouseEvent event : unhandledEvents) handleSingleEvent(event); // no need to remove, since dispatchEvents are generated by handlers
        for (Runnable dispatchEvent : dispatchList) dispatchEvent.run();

        unhandledEvents.clear();
        dispatchList.clear();
    }

    /**
     * Handle a single MouseEvent by adjusting the registry. Does not dispatch the event.
     * The event is validated before being handled.
     * @return whether or not the MouseEvent was handled successfully.
     */
    private boolean handleSingleEvent(MouseEvent event) {

        if (event instanceof MouseButtonEvent) return handleButtonEvent((MouseButtonEvent)event);
        if (event instanceof MouseMovedEvent) return handleMovedEvent((MouseMovedEvent)event);
        if (event instanceof MouseScrolledEvent) return handleScrolledEvent((MouseScrolledEvent)event);

        Assertions.warn("unknown MouseEvent class type: %s", event.getClass().getCanonicalName());
        return false;
    }

    /**
     * Handle a single MouseButtonEvent by adjusting the registry. Does not dispatch the event.
     * The event is validated before being handled. See: {@link #validateButtonEventTowardsRegistry(MouseButtonEvent)}
     * @return whether or not the MouseButtonEvent was handled successfully.
     */
    private boolean handleButtonEvent(MouseButtonEvent event) {
        if (!validateButtonEventTowardsRegistry(event)) return false;

        // update timestamp
        long unixNow = unixThisIteration;
        long unixOldTimestamp = buttonStatesTimestamps.getOrDefault(event.button, 0L);
        buttonStatesTimestamps.put(event.button, unixThisIteration);

        // update buttonState registry
        if (event.type == MouseButtonEvent.MouseButtonEventType.BUTTONDOWN) buttonStates.put(event.button, true);
        else if (event.type == MouseButtonEvent.MouseButtonEventType.BUTTONUP) buttonStates.put(event.button, false);
        buttonChanges.add(event.button);

        // check if any button is pressed
        isAnyButtonPressed = false;
        for (boolean state : buttonStates.values()) {
            if (state) { isAnyButtonPressed = true; break; }
        }

        // generate dispatch event
        switch (event.type) {
            case BUTTONDOWN:
                dispatchList.add(() -> processor.mouseDown(currentMouseX, currentMouseY, event.button));
                break;
            case BUTTONUP:
                dispatchList.add(() -> processor.mouseUp(currentMouseX, currentMouseY, event.button));
                break;
            default: Assertions.error("unknown event type: %s", event.type.name());
        }

        //check for 'clicked' event: is now released (and thereby WAS pressed)
        //                              and the 'pressed timestamp' came after the last move or drag event
        if (event.type == MouseButtonEvent.MouseButtonEventType.BUTTONUP && unixOldTimestamp > unixLastMoveOrDrag) {
            float holdDurationSeconds = (unixNow - unixOldTimestamp) / 1000f;
            dispatchList.add(() -> processor.mouseClicked(currentMouseX, currentMouseY, event.button, holdDurationSeconds));
        }

        return true;
    }

    /**
     * Handle a single MouseMovedEvent by adjusting the registry. Does not dispatch the event.
     * @return whether or not the MouseMovedEvent was handled successfully (always = true).
     */
    private boolean handleMovedEvent(MouseMovedEvent event) {
        currentMouseX = event.screenX;
        currentMouseY = event.screenY;

        unixLastMoveOrDrag = unixThisIteration;

        if (isAnyButtonPressed) {
            dispatchList.add(() -> processor.mouseDragged(event.screenX, event.screenY));
        } else {
            dispatchList.add(() -> processor.mouseMoved(event.screenX, event.screenY));
        }

        return true;
    }

    /**
     * Handle a single MouseScrolledEvent. Does not dispatch the event.
     * @return whether or not the MouseScrolledEvent was handled successfully (always = true).
     */
    private boolean handleScrolledEvent(MouseScrolledEvent event) {
        dispatchList.add(() -> processor.mouseScrolled(event.amountX, event.amountY));
        return true;
    }

    /**
     * Check that the given MouseButtonEvent does not introduce a conflicting buttonstate (in other words, cannot "press" if already pressed and vice versa).
     * @param event - The event.
     * @return true if event is "ok", false otherwise.
     */
    private boolean validateButtonEventTowardsRegistry(MouseButtonEvent event) {

        if (!buttonStates.containsKey(event.button)) return true;

        boolean ok = true;
        if (event.type == MouseButtonEvent.MouseButtonEventType.BUTTONDOWN && buttonStates.get(event.button))
            ok = false; //already pressed
        if (event.type == MouseButtonEvent.MouseButtonEventType.BUTTONUP && !buttonStates.get(event.button))
            ok = false; //already released

        if (!ok)
            Assertions.warn("mouse button: '%d' got event: '%s', but is already in that state (this should not happen). ignoring event...", event.button, event.type.name());

        return ok;
    }

    /**
     * Queue a MouseButtonEvent that a certain button was pressed.
     * This method must not be called again with the same button code before .queueButtonUp has been called with that button code.
     * @param button - The button code {@see MouseButtons}.
     */
    public void queueButtonDown(int button) {
        unhandledEvents.add(new MouseButtonEvent(MouseButtonEvent.MouseButtonEventType.BUTTONDOWN, button));
    }

    /**
     * Queue a MouseButtonEvent that a certain button was released.
     * This method must not be called again with the same button code before .queueButtonDown has been called with that button code.
     * @param button - The button code {@see MouseButtons}.
     */
    public void queueButtonUp(int button) {
        unhandledEvents.add(new MouseButtonEvent(MouseButtonEvent.MouseButtonEventType.BUTTONUP, button));
    }

    /**
     * Queue a MouseMovedEvent that the mouse moved.
     * @param screenX - The x coordinate, in pixel screen coordinates, of where the mouse moved to. The origin is in the upper left corner.
     * @param screenY - The y coordinate, in pixel screen coordinates, of where the mouse moved to. The origin is in the upper left corner.
     */
    public void queueMouseMove(int screenX, int screenY) {
        unhandledEvents.add(new MouseMovedEvent(screenX, screenY));
    }

    /**
     * Queue a MouseScrolledEvent that the mouse wheel was scrolled.
     * @param amountX - The amount of horizontal scroll (yes such mice do exist),
     *                  negative if the wheel was scrolled towards the left from the user's perspective, and
     *                  positive if the wheel was scrolled towards the right from the user's perspective.
     * @param amountY - The amount of vertical scroll,
     *                  negative if the wheel was scrolled towards the user, and
     *                  positive if the wheel was scrolled away from the user.
     */
    public void queueMouseScrolled(float amountX, float amountY) {
        unhandledEvents.add(new MouseScrolledEvent(amountX, amountY));
    }

    private static class MouseEvent {}

    private static class MouseButtonEvent extends MouseEvent {
        enum MouseButtonEventType { BUTTONDOWN, BUTTONUP }

        private MouseButtonEventType type;
        private int button;

        MouseButtonEvent(MouseButtonEventType type, int button) { this.type = type; this.button = button; }
    }

    private static class MouseMovedEvent extends MouseEvent {

        private int screenX, screenY;

        MouseMovedEvent(int screenX, int screenY) { this.screenX = screenX; this.screenY = screenY; }

    }

    private static class MouseScrolledEvent extends MouseEvent {

        private float amountX, amountY;

        MouseScrolledEvent(float amountX, float amountY) { this.amountX = amountX; this.amountY = amountY; }

    }

}